# -*- coding: utf-8 -*-
"""development.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17rOq_IggbwmL2ktQDeZoI6BpEssljLb7
"""

from langchain_openai import ChatOpenAI
llm = ChatOpenAI(
    model='gpt-4o',
    api_key="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",
    temperature=0.5,
)
# import fitz  # PyMuPDF
# from PIL import Image
# import numpy as np

# doc = fitz.open("docs/bill_issuers/EVERSOURCE/document_484/document_484.pdf")

# for i, page in enumerate(doc):
#     pix = page.get_pixmap(dpi=150)
#     img = Image.frombytes("RGB", [pix.width, pix.height], pix.samples)
#     np_img = np.array(img)
#     print(f"Page {i+1} shape: {np_img.shape}")
import re
import json
from copy import deepcopy
from typing import List, Dict, Union

class CustomJSONDecoder(json.JSONDecoder):
    def __init__(self, *args, process_func=None, **kwargs):
        super().__init__(*args, **kwargs, object_hook=self.object_hook)
        self.process_func = process_func

    def object_hook(self, dct):
        # Apply processing function to string values in dictionaries
        return {k: self.process_values(v) for k, v in dct.items()}

    def process_values(self, value):
        if isinstance(value, dict):
            return {k: self.process_values(v) for k, v in value.items()}
        elif isinstance(value, list):
            return [self.process_values(item) for item in value]
        elif isinstance(value, str):
            return value.replace(' '*100, '\n')
        else:
            return value


def convert_string_to_json(string_to_convert):
    # Remove any non-printable characters except newlines and tabs
    cleaned_string = re.sub(r'[^\x20-\x7E]', ' '*100, string_to_convert)

    # Escape newline characters within the string
    fixed_string = re.sub(r'(?<!\\)\n', r'\\n', cleaned_string)

    try:
        # Loading JSON
        return json.loads(fixed_string, cls=CustomJSONDecoder)
    except:
        # Managing double quotes
        quotes_managed = deepcopy(fixed_string)
        matches = re.finditer(r'(\".*\"\s*:\s*)\"(.*)\",?\s*\n', quotes_managed)
        for match in matches:
            if '"' in match.groups()[1]:
                start = match.start()
                end = match.end()
                quotes_managed = quotes_managed[:start] + match.groups()[0] + '"' + match.groups()[1].replace('"', r'\"') + '"' + quotes_managed[end:]

        # Loading JSON
        return json.loads(quotes_managed, cls=CustomJSONDecoder)

def llm_response_to_json(llm_response:str) -> Union[List, Dict]:
    # Clearing extra text if any
    llm_response = re.sub(r'^[^\[\{]*', '', llm_response)
    llm_response = re.sub(r'[^\]\}]*$', '', llm_response)

    try:
        return convert_string_to_json(llm_response)
    except:
        print(f"Response:\n{llm_response}")
        raise SyntaxError(f"Could not convert the LLM response to JSON format.")
system_prompt_by_details_extraction = """
You are an expert in understanding images and extracting data from the image.

You will be given image of a page from an electricity bill.
Your task is to extract the below requested information from the image of the bill.

### Output Schema:
Your response should be JSON serializable in the below mentioned format within backticks:
```
{{
    "customer_name" : (Optional[str]) <Name of the customer whose bill this is>,
    "statement_date_or_period" : (Optional[str]) <The date or period of the statement for which the bill is generated>,
    "account_number" : (Optional[str]) <The account number in the bill>
}}
```

Do not extract incorrect information. Focus on the text and extract it correctly.

Think step-by-step.
No talk, Just go
""".strip()
from io import BytesIO
import fitz  # PyMuPDF
from PIL import Image
import base64
from tqdm import tqdm
from langchain_core.messages import HumanMessage, SystemMessage, AIMessage

# Load PDF and LLM
doc = fitz.open("docs/bill_issuers/EVERSOURCE/document_990/document_990.pdf")

outputs = {}
page_images = []
for i, page in tqdm(list(enumerate(doc))):
    pix = page.get_pixmap(dpi=120)
    img = Image.frombytes("RGB", [pix.width, pix.height], pix.samples)

    # Convert to base64
    buffer = BytesIO()
    img.save(buffer, format="PNG")
    b64_image = base64.b64encode(buffer.getvalue()).decode()
    page_images.append(b64_image)

    # # Send to LLM
    # messages = [
    #     SystemMessage(content=system_prompt_by_details_extraction),
    #     HumanMessage(content=[
    #         {"type": "image_url", "image_url": {"url": f"data:image/png;base64,{b64_image}"}}
    #     ]),
    # ]

    # response = llm_response_to_json(llm.invoke(messages).content)
    # # print(f"Page {i+1} Response:\n{response.content}\n")

    # response['account_number'] = response['account_number'].replace(' ', '')
    # outputs[i+1] = response
system_message_by_similar_page = """
You are an expert in understanding images and matching 2 images by template matching.

We have a document with multiple bills attached in a single document.
We want to detect when a new bill starts in the document for which we will compare the first page of the document (definitely the first page of a bill) with each page of the document one by one.
Determine if the template of the pages match without considering the text present in the image.
You will be given the images of such two pages.

Your task is to determine if the 2 pages are same as per the template and things/tables/charts contained within them thus representing the start of a new bill.
The bills may be of multiple pages thus if the template matches, we say the new bill has started else we say that the same is continuing.

Output Schema:
Your response should be JSON serializable in the schema mentioned below:
```
{{
    "do_the_pages_match" : (bool) <'true' if the template matched and new bill has started else 'false'>
}}
```

No talk, Just go.
""".strip()

pages = [[1, len(page_images)]]
for ind in tqdm(range(1, len(page_images))):
    response = llm_response_to_json(llm.invoke([
        SystemMessage(content=system_message_by_similar_page),
        HumanMessage(content=[
            {"type": "text", "text": f"Image of the first page of the document."},
            {"type": "image_url", "image_url": {"url": f"data:image/png;base64,{page_images[0]}"}},
            {"type": "text", "text": f"Image of other page."},
            {"type": "image_url", "image_url": {"url": f"data:image/png;base64,{page_images[ind]}"}},
        ]),
    ]).content)
    print(f"{ind+1} : {response}")
    if response['do_the_pages_match']:
        pages[-1][1] = ind
        pages.append([ind+1, len(page_images)])

print()
print(pages)



from pprint import pprint
pprint(outputs)
for ind in range(1, len(outputs)):
    if outputs[ind]['customer_name'] is None:
        outputs[ind]
total_pages = len(list(outputs.keys()))
pages = [[1, total_pages]]
for key, value in sorted(outputs.items()):
    if key == 1:
        continue

    is_different = False
    if value['customer_name'] is not None and outputs[key-1]['customer_name'] is not None and value['customer_name'] != outputs[key-1]['customer_name']:
        is_different = True
    if value['statement_date_or_period'] is not None and outputs[key-1]['statement_date_or_period'] is not None and value['statement_date_or_period'] != outputs[key-1]['statement_date_or_period']:
        is_different = True
    if value['account_number'] is not None and outputs[key-1]['account_number'] is not None and value['account_number'] != outputs[key-1]['account_number']:
        is_different = True

    if is_different:
        pages[-1][-1] = key-1
        pages.append([key, total_pages])

print(pages)



from langchain_openai import ChatOpenAI
llm = ChatOpenAI(
    model='gpt-4o',
    api_key="sk-proj-vmOv1OEaeO0fS2XfsZYpT3BlbkFJUIaBwBY0ZtEJG0Nph6ev",
    temperature=0.5,
)

import json
def read_json(path):
    with open(path, 'r') as file:
        data = json.load(file)
    return data
from io import BytesIO
from pathlib import Path
import fitz  # PyMuPDF
from PIL import Image
import base64
from tqdm import tqdm
from langchain_core.messages import HumanMessage, SystemMessage, AIMessage

from utils import llm_response_to_json

system_message_by_similar_page = """
You are an expert in understanding images and matching 2 images by template matching.

We have a document with multiple bills attached in a single document.
We want to detect when a new bill starts in the document for which we will compare the first page of the document (definitely the first page of a bill) with each page of the document one by one.
Determine if the template of the pages match without considering the text present in the image.
You will be given the images of such two pages.

Your task is to determine if the 2 pages are same as per the template and things/tables/charts contained within them thus representing the start of a new bill.
The bills may be of multiple pages thus if the template matches, we say the new bill has started else we say that the same is continuing.

Output Schema:
Your response should be JSON serializable in the schema mentioned below:
```
{{
    "do_the_pages_match" : (bool) <'true' if the template matched and new bill has started else 'false'>
}}
```

No talk, Just go.
""".strip()

def get_bill_pages(pdf_path:Path):
    # Load PDF and LLM
    doc = fitz.open(pdf_path)

    outputs = {}
    page_images = []
    for i, page in tqdm(list(enumerate(doc))):
        pix = page.get_pixmap(dpi=150)
        img = Image.frombytes("RGB", [pix.width, pix.height], pix.samples)

        # Convert to base64
        buffer = BytesIO()
        img.save(buffer, format="PNG")
        b64_image = base64.b64encode(buffer.getvalue()).decode()
        page_images.append(b64_image)


    pages = [[1, len(page_images)]]
    for ind in tqdm(range(1, len(page_images))):
        response = llm_response_to_json(llm.invoke([
            SystemMessage(content=system_message_by_similar_page),
            HumanMessage(content=[
                {"type": "text", "text": f"Image of the first page of the document."},
                {"type": "image_url", "image_url": {"url": f"data:image/png;base64,{page_images[0]}"}},
                {"type": "text", "text": f"Image of other page."},
                {"type": "image_url", "image_url": {"url": f"data:image/png;base64,{page_images[ind]}"}},
            ]),
        ]).content)
        print(f"{ind+1} : {response}")
        if response['do_the_pages_match']:
            pages[-1][1] = ind
            pages.append([ind+1, len(page_images)])

    print()
    print(pages)
    return pages




import fitz  # PyMuPDF
from pathlib import Path

def split_pdf(input_pdf_path:Path, output_specs):
    if len(output_specs) == 1:
        return [input_pdf_path]

    final_paths = []
    doc = fitz.open(input_pdf_path)
    for idx, (start, end) in enumerate(output_specs):
        sub_doc = fitz.open()
        for page_num in range(start - 1, end):  # PyMuPDF uses 0-based indexing
            sub_doc.insert_pdf(doc, from_page=page_num, to_page=page_num)

        split_pdf_path = Path('.'.join(str(input_pdf_path).split('.')[:-1]) + f"_{start}_{end}.pdf")
        sub_doc.save(split_pdf_path)
        final_paths.append(split_pdf_path)
        sub_doc.close()
    doc.close()

    return final_paths
from pathlib import Path
import traceback
import json
from new_main import *

# Setup
issuer = "COMED"

bill_path = Path(r"C:\Users\Lenovo\Desktop\BenContracting\datasets\bill_issuers").joinpath(issuer.upper())
# prev_results_for_doc = list(set([entry.get('documentId') for entry in read_json('final_bills_from_structure.json')]))
# done_results_for_doc = list(set(['_'.join(entry.get('filename', '').split('_')[:2]) for relation, entries in read_json('bill_variations_AMEREN_ILLINOIS_v1.json')['Eversource'].items() for entry in entries]))
# done_results_for_doc_v2 = list(set(['_'.join(entry.get('filename', '').split('_')[:2]) for relation, entries in read_json('bill_variations_kedia_v2.json')['Eversource'].items() for entry in entries]))

manager = BillVariationManager("bill_variations_COMED_DOC_SPLIT_TEST.json")
count = 0

# Loop through folders
for sample_dir in bill_path.glob("document_*"):
    # if sample_dir.name in prev_results_for_doc:
    #     print(f"skipping: {sample_dir.name}")
    #     continue  # ⬅️ Skip if not in target list
    # if sample_dir.name in done_results_for_doc:
    #     print(f"skipping: {sample_dir.name} coz done previously")
    #     # count += 1
    #     continue  # ⬅️ Skip if not in target lis
    # if sample_dir.name in done_results_for_doc_v2:
    #     print(f"skipping: {sample_dir.name} coz already done")
    #     # count += 1
    #     continue  # ⬅️ Skip if not in target lis
    if sample_dir.name not in ['document_154']:
        print(f"skipping: {sample_dir.name} coz not in list")
        # count += 1
        continue  # ⬅️ Skip if not in target lis

    # AMEREN_ILLINOIS: ['document_1034', 'document_528', 'document_659', 'document_721', 'document_701']
    # NATIONAL_GRID: ['document_910']
    # NIPSCO
    # DOMINION_ENERGY
    # DOMINION_ENERGY_VIRGINIA

    print(f"processing: {sample_dir.name}")

    sample_number = sample_dir.name.replace("document_", "")
    pdf_file_path = Path(bill_path).joinpath(f"document_{sample_number}\\document_{sample_number}.pdf")

    if len(pdf_file_path.parent.glob(f"{pdf_file_path.parent.name}_*_*.pdf")) > 0:
        split_pdf_paths = list(pdf_file_path.parent.glob(f"{pdf_file_path.parent.name}_*_*.pdf"))
    else:
        pages = get_bill_pages(pdf_file_path)
        split_pdf_paths = split_pdf(pdf_file_path, pages)

    for oper_pdf_path in split_pdf_paths:
        # if not md_file_path.exists():
        #     print(f"❌ Skipping missing file: {md_file_path}")
        #     continue
        try:
            image_extraction_prompt = (
                "You are extracting data from a utility bill image. "
                "Extract all informative parts exactly as shown, character by character, in markdown format. "
                "Do not omit or alter any informative detail. "
                "Keep only informative sections of the bill. "
                "For plots: Only mention plots that show historical usage by month during the last year. "
                "For such plots, do not extract their data. Instead, describe the plot in one sentence, e.g., "
                '"[Bar chart showing monthly usage for the last year]". '
                "If usage values are shown only on the y-axis (not labeled on the bars), do not extract any values from the plot."
            )

            md_content = im2txt(str(sample_dir), sample_number, image_extraction_prompt)
            oper_pdf_path.with_suffix('.md').write_text(md_content, encoding='utf-8')

            # Classify
            cls_usr_msg = get_cls_usr_prompt(md_content)
            cls_sys_msg = "You are a helpful assistant for classifying utility bills."
            rsp_cls, _ = send_query(cls_sys_msg, cls_usr_msg, file_path=None)

            cls_dict = fix_llm_json(rsp_cls)
            cls_name = determine_variation_class_name(cls_dict)

            # Extract
            result = run(md_content, oper_pdf_path)
            result["filename"] = '.'.join(oper_pdf_path.name.split('.')[:-1])
            result["issuer"] = issuer

            fixed_result = fix_years(result)
            manager.add_result(issuer, cls_name, fixed_result)


            count += 1
            print(f"✅ Processed {sample_dir.name} → {cls_name}")
            # print(fixed_result)

            if count >= 3:
                break
        except Exception as e:
            print(f"Error: {e}")
            print(f"Traceback: {traceback.format_exc()}")
            pass


        # if count >= 10:
        #     break


from pathlib import Path
path = Path(r'C:\Users\Lenovo\Desktop\BenContracting\dataset\bills\bill_issuers\COMED\document_83\document_83_2_3.pdf')
path.with_suffix('').name
'document_83_2_3'
# 281 - Add dec 2023
# 287 - customer + /PUBLIC WORKS
# 311 - customer + /PUBLIC WORKS
# 323 - meter_number should not be there
# 470 - years are at -1
# 471 - meter number incorrect
# 485 - address pin incorrect
# 666 - customer name incorrect

import json
def read_json(path):
    with open(path, 'r') as file:
        data = json.load(file)
    return data
def write_json(path, data):
    with open(path, 'w') as file:
        json.dump(data, file, indent=2)
comed_docs = [
 'document_427',
 'document_524',
 'document_546',
 'document_60',
 'document_724',
 'document_76',
 'document_788',
 'document_789',
 'document_80',
 'document_82',
 'document_826',
 'document_831',
 'document_837',
 'document_840',
 'document_843',
 'document_852',
 'document_854',
 'document_86',
 'document_89',
]
gt_data = read_json(r'C:\Users\Lenovo\Desktop\BenContracting\bill_ocr\project\FinalBills\final_bills_COMED_GT.json')
gt_data = sorted(gt_data, key=lambda x:int(x['documentId'].split('_')[1]))
write_json(r'C:\Users\Lenovo\Desktop\BenContracting\bill_ocr\project\testing\COMED_GT.json', gt_data)

from collections import Counter
final = read_json('test_final.json')
docs = [doc['documentId'] for doc in final]
print(len(docs))
print(len(set(docs)))
print(Counter(docs).most_common(7))
kedia = read_json('bill_variations_kedia.json')
new = read_json('bill_variations_kedia_v2.json')
kedia_docs = [doc['filename'] for doc in kedia['Eversource']['one_to_one']]
new_docs = [doc['filename'] for doc in new['Eversource']['one_to_one']]
(set(kedia_docs) - set(new_docs)) - set(['document_303', 'document_315', 'document_820', 'document_990'] + ['document_669',
 'document_671',
 'document_672',
 'document_673',
 'document_675',
 'document_676',
 'document_677',
 'document_679',
 'document_680',
 'document_681',
 'document_682',
 'document_683',
 'document_732',
 'document_733',
 'document_798',
 'document_318',
'document_992'])
from usage_by_plots import extract_yearly_breakdown

resp = extract_yearly_breakdown(
    r'C:\Users\Lenovo\Desktop\BenContracting\dataset\bills\bill_issuers\COMED\document_837\document_837.pdf',
    'electricity'
)




from matplotlib import pyplot as plt

for ind in range(len(resp)):
    plt.imshow(resp[ind])
    plt.show()
from pprint import pprint
pprint({'data_found': True, 'breakdown': {'June 2023': 8093.0, 'July 2023': 7580.0, 'August 2023': 7048.0, 'September 2023': 8117.0, 'October 2023': 7230.0, 'November 2023': 6594.0, 'December 2023': 7433.0, 'January 2024': 7794.0, 'February 2024': 6402.0, 'March 2024': 7852.0, 'April 2024': 6102.0, 'May 2024': 6867.0, 'June 2024': 7770.0}})




from pathlib import Path
from usage_by_plots import extract_plots_from_pdf
plots = extract_plots_from_pdf(Path(r'C:\Users\Lenovo\Desktop\BenContracting\dataset\bills\bill_issuers\COMED\document_843\document_843.pdf'))



from matplotlib import pyplot as plt
for p in plots:
    print(p.shape)
    plt.imshow(p)
    plt.show()